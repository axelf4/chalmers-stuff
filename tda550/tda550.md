# TDA550

Barring any user-facing aspects,
what makes one program better than another
is being more maintainable.
What follows are refinements on what is meant by "maintainable"
in roughly decreasing order of abstractness.

## Design Principles

* **High-Cohesion Low-Coupling (HCLC)**

  High cohesion increases code readability,
  while low coupling means a module can be readily replaced.
  These two are often correlated.

* **Command-Query Separation (CQS)**

  > Asking a question should not change the answer.

### SOLID Principles

These are principles of the *class design* aspect of Object Oriented
design, [formulated by Robert C. Martin][PrinciplesOfOod].
While these are sound, see [this article][qntm20] for critique on
Robert's book.

* **Single Responsibility Principle (SRP)**

  > Gather together the things that change for the same reasons.
    Separate those things that change for different reasons.
  
  Reformulation of HCLC.
  Though Robert C. Martin emphasizes that code by itself does not warrant change,
  [*people* request changes][martin14],
  and a change mandated by the tech department of an organization
  should never cause malfunctions for say the financial department.
  
* **Open-Closed Principle (OCP)**
  
  > Software modules should be open for extension,
    but closed for modification.
  
  Write code that does not have to change every time the requirements
  change,
  specifically by *anticipating* possible desired improvements.
  Can be taken too far - easily deletable code already is infinitely extensible.
  
  The primary mechanisms for achieving this are abstraction and
  polymorphism.
  
* **Liskov Substitution Principle (LSP)**
  
  > For `S` to be a subtype of `T`, objects of type `T` may be
    substituted with objects of type `S` without altering any desirable
    program property.&mdash;Barbara Liskov
  
  This is a particular definition of a subtype relation,
  that becomes a prerequisite for conforming to OCP since it
  allows functions to be made to use derived classes instead
  *without them knowing it*.
  
  Something should be a subtype only if its extrinsic behaviour
  can be made consistent with that of its supertype,
  or, to relate to Design by Contract:
  
  > ...when [overriding] a routine, you may only replace its
    precondition by a weaker one, and its postcondition by a stronger
    one.&mdash;Bertrand Meyer
  
  Otherwise we would have to change the client code,
  which violates OCP.
  
* **Interface Segregation Principle (ISP)**
  
  > No client should be forced to depend on methods it does not use.
  
  "Fat" interfaces are a sign of high coupling.
  
* **Dependency Inversion Principle (DIP)**
  
  > Depend on abstractions, not on concrete implementations.
  
  Focusing only on interactions between high- and low-level layers
  when abstracting can lead to less coupled design.
  The most concrete benefit being that the low-level layer
  can be swapped out.
  
  <table>
  <thead>
	  <caption>
		  Instead of higher-level layers depending on lower-level layers,
		  both depend on abstractions around the needs of higher-level layers.
		  The dependency is <em>inverted</em>.
	  </caption>
	  <tr><th>Before</th><th>After</th></tr>
  </thead>
	  <tbody>
		  <tr>
			  <td>
				  <!--
				  @startuml before_dip
				  skinparam monochrome true
				  "Higher level" ..> "Lower level"
				  hide members
				  @enduml
				  -->
				  <img alt="Before DIP" src="before_dip.svg">
			  </td>
			  <td>
				  <!--
				  @startuml after_dip
				  skinparam monochrome true
				  interface Abstraction
				  "Higher level" ..> Abstraction
				  "Lower level" ..|> Abstraction
				  hide members
				  @enduml
				  -->
				  <img alt="After DIP" src="after_dip.svg">
			  </td>
		  </tr>
	  <tbody>
  </table>

## Design Patterns

### Model-View-Controller (MVC)

Three way division of an application into
(M) the representation of the underlying domain model,
(V) the way the model is represented to the user and
(C) the way the user interacts with it,
introduced by [this article][krasner88].
The primary benefit is decoupling the model from the view.

<figure>
<img alt="MVC state and message sending" src="mvc-state-messages.svg">
<figcaption>MVC state and message sending.</figcaption>
</figure>							

Models can have one or several view, controller pairs.
The model is often changed as a result of
a controller responding to a user action.
This should be reflected in *all* views,
which is done through the *observer* pattern.
Note that while the controllers are responsible for "User input device interaction",
the views should be the ones that "Display interaction views".
Take for example the counter example used in the initial publication:

<figure>
	<!--
	@startsalt mvc_counter
	{^Counter
	  { [+]
		  [-] } | val: 0
	}
	@endsalt
	-->
	<img alt="Example Counter application" src="mvc_counter.svg">
	<figcaption>Simple Counter app.</figcaption>
</figure>

In this example the view is the one connecting `+`/`-` button presses to the model,
and the controller only manages the context menu
(which more modern GUI frameworks such as Swing also implement as
interaction views).

[HCLC]: #high-cohesion-low-coupling
[PrinciplesOfOod]: http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
[qntm20]: https://qntm.org/clean
[martin14]: https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html
[krasner88]: https://www.researchgate.net/profile/Stephen_Pope/publication/248825145_A_cookbook_for_using_the_model_-_view_controller_user_interface_paradigm_in_Smalltalk_-_80/links/5436c5f30cf2643ab9888926/A-cookbook-for-using-the-model-view-controller-user-interface-paradigm-in-Smalltalk-80.pdf